[] : references of elements in the code itself

ALARM CLOCK
	Creating a double linked list [ sleep_list ] storing the sleeping threads, using list.c. 
	The caller of [ thread_block(void) ] adds itself as [ thread struct element ] and its sleeping time ([ wakeup_tick ]) to the list, using
	the method [ list_insert_ordered (struct list *list, struct list_elem *elem,list_less_func *less, void *aux) ].
	The [ timer_interrupt ] handler will then check the first thread on the list and check if its wake up time has arrived. If it's wake up time,
	it will use [ thread_unblock() ] to wake it up, and go over the following threads on the list until it reaches a thread whose wake up time has not
	come yet.	

PRIORITY SCHEDULING
	TODO : manage the [ ready_list ] so that it is sorted along the priorties : first element should me the one with the highest priority
	solution	-> either sort it regularly according to its priority level but have to maintain the queue order among elements within the same level 
				-> either create a queue per priority level and create a new (or change) the [ ready_list ]	
	
	Alternative solution:
	Everytime we insert a thread to the ready list we need to insert it in the correct location. We can use the built in function list_insert_ordered() 
	We will replace list_push_back() with list_insert_ordered(), that way the threads will always be sorted, and when we pop a thread it will pop the
	thread with the highest priority.
	list_push_back() is being called in thread_Unblock(), thread_yield(), init_thread()   
	
	TODO : add a preemption when higher-priority thread arrives. Addition of the check if a higher priority thread is about to be created in [ thread_unblock(struct thread) ] and [ thread_set_priority(struct thread) ].
		- if so the current thread has to yield and the higher priority thread must be added to the [ ready_list ] as the last element so that it will be dequeued right after
		- if not just resume add the created thread to the [ ready_list ]
		
	TODO : in a semaphore the first out of synchronization must be the one with the highest priority (TO FIX)
		When a lock is released ([ sema_up() ]) we will access [ lock->semaphore->waiters ] and delete the waiter with the highest
		priority from the list. Then, we will use [ thread_unblock() ] to activate that thread.

	TODO: When a thread lowers its priority such that it no longer has the highest priority, the thread should immediately yield the CPU.
		- Add a check in [ thread_set_priority(struct thread) ] such that when the running thread's priority changes,
		we will compare it to the priority of the first thread in the ready list and yield the CPU if its priority is higher.  

	TODO: Priority donation to prevent priority inversion (nested priority)
		The running thread will try to acquire the lock using [ lock_acquire(lock) ]
		We will change [ lock_acquire() ] implementation such that it will check if the lock is free using [ sema_down() ]
			- if the lock is free, he will take it
			- otherwise, we will check if the thread holding the lock has a lower priority.
				if yes, we will recursively donate the priority.
				* Need to add a field for struct thread that is pointing at the lock that the thread needs.
				  We can access the thread that holds the lock through the pointer and recursively donate priority.
		Multiple donations - if multiple threads are donating to the same thread that holds a lock, we need to manage that.*
		solution 	- Implement a donations list which is always sorted. When a donation is made, we will add the donation to the list.
					when the thread that donated the priority stops waiting, we will erase its priority value from the list (should be the top of the list) 

ADVANCED SCHEDULER : 
	we set [ TIMER_FREQ ] to be the number of ticks per update
	TODO : create [ list_priority_queues ] where [ PRI_MIN + PRI_MAX + 1 ] = 64 = [ sizeof(list_priority_queues) ] on the boot of the os.
	TODO : If the user sets [ thread_mlfqs = true ], the scheduling will be done using MLFQS. 
	TODO : New functions or modifications for the state of using MLFQS:
			Inserting a thread to the correct priority queue
			Returning the next thread to run
				- Go over the queues starting with the highest priority until finding a non-empty queue
			Change the [ thread_yield() ] function to adapt to the 2 different scenarios 
	TODO : Add [ int nice ] field to thread.c
		- Must be an integer between -20 and 20
		- Initially 0
		- Implement the functions [ thread_get_nice(), thread_set_nice() ]
	TODO : Add [ int recent_cpu] field to thread.c
		- Initially 0, or the value of the parent thread.
		- May be negative
		- Needs to be rounded down
		- Implement the function [ thread_get_recent_cpu() ]
		- Each time a timer interrupt occurs, recent_cpu is incremented by 1 for the 
					running thread only, unless the idle thread is running.
	TODO : Add global variable [ load_avg ] to thread.h
		- Initially 0
		- Implement the function [ thread_get_load_avg() ]
	TODO :	every second update 
		- [ load_avg ] every second [ mlfqs_update_load_avg() ] (what about blocked threads ?)
		- [ recent_cpu ] and [ priority ] of every threads (even the blocked ones) according to the formulas. [ mlfqs_update_recent_cpu(thread t) ] and [ mlfqs_update_priority(thread t) ]
			every 4 ticks update
		- [ priority ] of every threads according to the formulas
			- Should be between 0 and 63
		- Yield the CPU if a thread was added to a higher priority queue than the current
	TODO : update the [ next_thread_to_run() ] function so that it updates the next thread to schedule by looping through the [ list_priority_queues ]

	TODO : preemption if a higher priority thread is in a ready queue -> yield the current thread
	TODO : If multiple threads are in the same priority queue, we need to schedule them using round robin, using [ thread_tick() ]
